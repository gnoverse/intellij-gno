{
  parserClass='com.github.intellij.gno.parser.GnoParser'

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  elementTypeHolderClass='com.github.intellij.gno.psi.GnoTypes'
  elementTypeClass='com.github.intellij.gno.psi.GnoElementType'
  tokenTypeClass='com.github.intellij.gno.psi.GnoTokenType'

  psiClassPrefix='Gno'
  psiImplClassSuffix='Impl'
  psiPackage='com.github.intellij.gno.psi'
  psiImplPackage='com.github.intellij.gno.psi.impl'
  psiImplUtilClass='com.github.intellij.gno.psi.impl.GnoPsiImplUtil'

  tokens=[
    LBRACE               =  '{'
    RBRACE               =  '}'
    LBRACK               =  '['
    RBRACK               =  ']'
    LPAREN               =  '('
    RPAREN               =  ')'
    COLON                =  ':'
    SEMICOLON            =  ';'
    COMMA                =  ','
    EQ                   =  '=='
    ASSIGN               =  '='
    NOT_EQ               =  '!='
    NOT                  =  '!'
    PLUS_PLUS            =  '++'
    PLUS_ASSIGN          =  '+='
    PLUS                 =  '+'
    MINUS_MINUS          =  '--'
    MINUS_ASSIGN         =  '-='
    MINUS                =  '-'
    COND_OR              =  '||'
    BIT_OR_ASSIGN        =  '|='
    BIT_CLEAR_ASSIGN     =  '&^='
    BIT_CLEAR            =  '&^'
    COND_AND             =  '&&'
    BIT_AND_ASSIGN       =  '&='
    BIT_AND              =  '&'
    BIT_OR               =  '|'
    SHIFT_LEFT_ASSIGN    =  '<<='
    SHIFT_LEFT           =  '<<'
    SEND_CHANNEL         =  '<-'
    LESS_OR_EQUAL        =  '<='
    LESS                 =  '<'
    BIT_XOR_ASSIGN       =  '^='
    BIT_XOR              =  '^'
    MUL_ASSIGN           =  '*='
    MUL                  =  '*'
    QUOTIENT_ASSIGN      =  '/='
    QUOTIENT             =  '/'
    REMAINDER_ASSIGN     =  '%='
    REMAINDER            =  '%'
    SHIFT_RIGHT_ASSIGN   =  '>>='
    SHIFT_RIGHT          =  '>>'
    GREATER_OR_EQUAL     =  '>='
    GREATER              =  '>'
    VAR_ASSIGN           =  ':='
    TRIPLE_DOT           =  '...'
    DOT                  =  '.'

    IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    INT        = 'regexp:[0-9]+'
    STRING     = 'regexp:"([^"\\\n\r]|\\.)*"'
    COMMENT    = 'regexp://[^\n]*|/\\*.*?\\*/'
    WHITE_SPACE = 'regexp:[ \t]+'
    EOL        = 'regexp:\r?\n+'



    PACKAGE    = 'package'
    IMPORT     = 'import'
    CONST      = 'const'
    VAR        = 'var'
    FUNC       = 'func'
    TYPE       = 'type'
    STRUCT     = 'struct'
    INTERFACE  = 'interface'
    MAP        = 'map'
    SELECT     = 'select'
    SWITCH     = 'switch'
    CASE       = 'case'
    DEFAULT    = 'default'
    FOR        = 'for'
    IF         = 'if'
    ELSE       = 'else'
    RETURN     = 'return'
    GO         = 'go'
    DEFER      = 'defer'
    CHAN       = 'chan'
    NIL        = 'nil'
  ]
  generateTokenAccessors=true
}


File ::= (EOL | COMMENT)* PackageClause (EOL | COMMENT)* ImportList? (EOL | COMMENT)* TopLevelDeclaration* (EOL | COMMENT)*

PackageClause ::= PACKAGE IDENTIFIER (EOL | COMMENT)*
ImportDeclaration ::= IMPORT ( ImportSpec | LPAREN ImportSpecList? RPAREN ) (EOL | COMMENT)*


ImportList ::= (EOL | COMMENT)* ImportDeclaration*


ImportSpecList ::=
    ( EOL )* ImportSpec
    ( ( EOL )+ ImportSpec )*
    ( EOL )*

ImportSpec     ::= STRING


TopLevelDeclaration ::=
    FunctionDeclaration
  | TypeDeclaration
  | VarDeclaration
  | ConstDeclaration
  | PropertyDeclaration

PropertyDeclaration ::= IDENTIFIER VAR_ASSIGN Expression
{
  methods=[getKey getValue getName]
}

ShortVarDeclaration ::= VarDefinitionList VAR_ASSIGN ExpressionList {pin=2}
VarDefinitionList ::= IDENTIFIER ( COMMA IDENTIFIER )*
ExpressionList    ::= Expression ( COMMA Expression )*
VarDeclaration ::= VAR (VarSpec | GroupedVarDeclaration)

GroupedVarDeclaration ::= LPAREN EOL VarSpecList RPAREN

VarSpec ::= IDENTIFIER TypeBody (ASSIGN Expression)?

VarSpecList ::= (EOL | COMMENT)* VarSpec (EOL | COMMENT)* (VarSpec (EOL | COMMENT)*)*

ConstDeclaration ::= CONST (ConstSpec | GroupedConstDeclaration)

GroupedConstDeclaration ::= LPAREN EOL ConstSpecList RPAREN

ConstSpec ::= IDENTIFIER TypeAnnotation? ASSIGN Expression

ConstSpecList ::= (EOL | COMMENT)* ConstSpec (EOL | COMMENT)* (ConstSpec (EOL | COMMENT)*)*

TypeAnnotation ::= TypeBody


FunctionDeclaration ::= FUNC Receiver? IDENTIFIER Signature Block
Receiver ::= LPAREN ReceiverParameter RPAREN
ReceiverParameter ::= IDENTIFIER TypeBody

Signature ::= LPAREN Parameters? RPAREN Result?

Result ::= LPAREN Parameters RPAREN | TypeBody

Parameters ::= ParameterDeclaration (COMMA ParameterDeclaration)* COMMA?

ParameterDeclaration ::= (IDENTIFIER TypeBody) | TypeBody

TypeDeclaration ::= TYPE (TypeSpec | GroupedTypeDeclaration)

GroupedTypeDeclaration ::= LPAREN EOL TypeSpecList RPAREN

TypeSpec ::= IDENTIFIER TypeBody

TypeSpecList ::= (EOL | COMMENT)* TypeSpec (EOL | COMMENT)* (TypeSpec (EOL | COMMENT)*)*


TypeBody ::=
    '(' TypeBody ')'
  | PointerType
  | StructType
  | MapType
  | ArrayType
  | FunctionType
  | QualifiedIdentifier
  | TypeName

QualifiedIdentifier ::= IDENTIFIER '.' IDENTIFIER


TypeName ::= IDENTIFIER ('.' IDENTIFIER )*

StructType ::= STRUCT LBRACE Fields? RBRACE

Fields ::=
    ( EOL )*
    FieldDeclaration
    ( (EOL | SEMICOLON)+ FieldDeclaration )*
    ( EOL | SEMICOLON )*



FieldDeclaration ::= IdentifierList FieldType
FieldType ::= TypeBody
IdentifierList ::= IDENTIFIER ( COMMA IDENTIFIER )*

MapType ::= MAP LBRACK TypeBody RBRACK TypeBody

ArrayType ::= LBRACK INT? RBRACK TypeBody

PointerType ::= MUL TypeName

FunctionType ::= FUNC Signature

Block ::= LBRACE (EOL | Statement)* RBRACE {pin=1}



Statement ::=
    Block
  | EOL
  | IfStatement
  | ForStatement
  | SwitchStatement
  | ReturnStatement
  | SimpleStatement

AssignStatement ::= Expression AssignOp Expression
IncDecStatement ::= Expression (PLUS_PLUS | MINUS_MINUS)
AssignOp ::= ASSIGN        // =
           | PLUS_ASSIGN   // +=
           | MINUS_ASSIGN  // -=
           | MUL_ASSIGN    // *=
           | QUOTIENT_ASSIGN // /=
           | REMAINDER_ASSIGN // %=
           | BIT_AND_ASSIGN   // &=
           | BIT_OR_ASSIGN    // |=
           | BIT_XOR_ASSIGN   // ^=
           | SHIFT_LEFT_ASSIGN // <<=
           | SHIFT_RIGHT_ASSIGN // >>=
           | BIT_CLEAR_ASSIGN // &^=

SimpleStatement ::=
    ShortVarDeclaration
  | IncDecStatement
  | AssignStatement
  | ExpressionStatement


ExpressionStatement ::= Expression


Expression ::= OrExpr {pin=1}
OrExpr ::= AndExpr ( COND_OR AndExpr )*
AndExpr ::= CompareExpr ( COND_AND CompareExpr )*
CompareExpr ::= ShiftExpr ( CompareOp ShiftExpr )*
CompareOp ::= EQ | NOT_EQ | LESS | LESS_OR_EQUAL | GREATER | GREATER_OR_EQUAL
ShiftExpr ::= AddExpr ( ShiftOp AddExpr )*
ShiftOp ::= SHIFT_LEFT | SHIFT_RIGHT | BIT_CLEAR
AddExpr ::= MulExpr ( AddOp MulExpr )*
AddOp ::= PLUS | MINUS | BIT_OR | BIT_XOR
MulExpr ::= UnaryExpr ( MulOp UnaryExpr )*
MulOp ::= MUL | QUOTIENT | REMAINDER | BIT_AND
UnaryExpr ::= ( UnaryOp )* PrimaryExpr {pin=1}
UnaryOp ::= PLUS    // +
          | MINUS   // -
          | NOT     // !
          | BIT_AND // &
          | BIT_XOR // ^

PrimaryExpr ::=
    CompositeLiteral
  | TypeConversion
  | (IDENTIFIER | Literal)
    (SelectorSuffix | CallSuffix | TypeAssertionSuffix)*
  | LPAREN Expression RPAREN

TypeConversion ::= LPAREN MUL? TypeName RPAREN LPAREN Expression RPAREN

TypeAssertionSuffix ::= '.' LPAREN TypeBody RPAREN

CompositeLiteral ::= TypeName LBRACE (EOL | FieldLiteralList)? RBRACE {pin=1}

FieldLiteralList ::= FieldLiteral ( COMMA FieldLiteral )* (EOL | COMMA)?

FieldLiteral ::= IDENTIFIER (COLON Expression)?



SelectorSuffix ::= '.' IDENTIFIER
CallSuffix     ::= LPAREN Arguments? RPAREN
Literal        ::= INT | STRING | NIL
Arguments ::= (EOL | Expression (COMMA Expression)*)? COMMA?

IfStatement ::= IF Expression Block ELSE? Block?

ForStatement ::= FOR Expression? Block

SwitchStatement ::= SWITCH Expression? LBRACE CaseClauses RBRACE

CaseClauses ::= CaseClause*

CaseClause ::= CASE Expression COLON Statement*

ReturnStatement ::= RETURN ExpressionList?
