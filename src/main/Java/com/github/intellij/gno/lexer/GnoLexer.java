// Generated by JFlex 1.9.1 http://jflex.de/  (tweaked for IntelliJ platform)
// source: _GnoLexer.flex

package com.github.intellij.gno.lexer;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;

import static com.intellij.psi.TokenType.BAD_CHARACTER;
import static com.intellij.psi.TokenType.WHITE_SPACE;
import static com.github.intellij.gno.psi.GnoTypes.*;


public class GnoLexer implements FlexLexer {

  /** This character denotes the end of file */
  public static final int YYEOF = -1;

  /** initial size of the lookahead buffer */
  private static final int ZZ_BUFFERSIZE = 16384;

  /** lexical states */
  public static final int YYINITIAL = 0;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private static final int ZZ_LEXSTATE[] = {
     0, 0
  };

  /**
   * Top-level table for translating characters to character classes
   */
  private static final int [] ZZ_CMAP_TOP = zzUnpackcmap_top();

  private static final String ZZ_CMAP_TOP_PACKED_0 =
    "\1\0\25\u0100\1\u0200\11\u0100\1\u0300\17\u0100\1\u0400\u10cf\u0100";

  private static int [] zzUnpackcmap_top() {
    int [] result = new int[4352];
    int offset = 0;
    offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackcmap_top(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /**
   * Second-level tables for translating characters to character classes
   */
  private static final int [] ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks();

  private static final String ZZ_CMAP_BLOCKS_PACKED_0 =
    "\11\0\5\1\22\0\1\1\1\0\1\2\5\0\1\3"+
    "\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13"+
    "\10\0\1\14\3\0\1\15\1\0\1\16\1\0\1\17"+
    "\1\0\1\20\1\21\7\0\1\22\1\0\1\23\1\24"+
    "\3\0\1\25\2\0\1\26\3\0\1\27\1\30\1\0"+
    "\1\31\1\0\1\32\1\0\1\33\1\0\1\34\1\0"+
    "\1\35\1\36\1\37\1\40\1\41\2\0\1\42\1\43"+
    "\1\44\1\45\1\46\1\0\1\47\1\50\1\51\1\52"+
    "\1\53\1\54\1\0\1\55\1\56\1\57\1\0\1\60"+
    "\7\0\1\1\32\0\1\1\u01df\0\1\1\177\0\13\1"+
    "\35\0\2\1\5\0\1\1\57\0\1\1\240\0\1\1"+
    "\377\0";

  private static int [] zzUnpackcmap_blocks() {
    int [] result = new int[1280];
    int offset = 0;
    offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackcmap_blocks(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /**
   * Translates DFA states to action switch labels.
   */
  private static final int [] ZZ_ACTION = zzUnpackAction();

  private static final String ZZ_ACTION_PACKED_0 =
    "\1\0\1\1\1\2\1\1\1\3\1\4\1\5\1\6"+
    "\1\7\1\10\1\11\1\12\3\1\1\13\1\14\11\1"+
    "\1\15\1\16\14\0\1\17\23\0\1\20\3\0\1\21"+
    "\5\0\1\22\7\0\1\23\1\0\1\24\1\25\6\0"+
    "\1\26\1\27\1\30\5\0\1\31\11\0\1\32\1\0"+
    "\1\33\1\0\1\34\1\35\1\36\1\37\12\0\1\40"+
    "\3\0\1\41\11\0\1\42\2\0\1\43\10\0\1\44";

  private static int [] zzUnpackAction() {
    int [] result = new int[151];
    int offset = 0;
    offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAction(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /**
   * Translates a state to a row index in the transition table
   */
  private static final int [] ZZ_ROWMAP = zzUnpackRowMap();

  private static final String ZZ_ROWMAP_PACKED_0 =
    "\0\0\0\61\0\142\0\223\0\61\0\61\0\61\0\61"+
    "\0\61\0\61\0\61\0\61\0\304\0\365\0\u0126\0\u0157"+
    "\0\61\0\u0188\0\u01b9\0\u01ea\0\u021b\0\u024c\0\u027d\0\u02ae"+
    "\0\u02df\0\u0310\0\61\0\61\0\u0341\0\u0372\0\u03a3\0\u03d4"+
    "\0\u0405\0\u0436\0\u0467\0\u0498\0\u04c9\0\u04fa\0\u052b\0\u055c"+
    "\0\61\0\u058d\0\u05be\0\u05ef\0\u0620\0\u0651\0\u0682\0\u06b3"+
    "\0\u06e4\0\u0715\0\u0746\0\u0777\0\u07a8\0\u07d9\0\u080a\0\u083b"+
    "\0\u086c\0\u089d\0\u08ce\0\u08ff\0\61\0\u0930\0\u0961\0\u0992"+
    "\0\61\0\u09c3\0\u09f4\0\u0a25\0\u0a56\0\u0a87\0\61\0\u0ab8"+
    "\0\u0ae9\0\u0b1a\0\u0b4b\0\u0b7c\0\u0bad\0\u0bde\0\61\0\u0c0f"+
    "\0\61\0\61\0\u0c40\0\u0c71\0\u0ca2\0\u0cd3\0\u0d04\0\u0d35"+
    "\0\61\0\61\0\61\0\u0d66\0\u0d97\0\u0dc8\0\u0df9\0\u0e2a"+
    "\0\61\0\u0e5b\0\u0e8c\0\u0ebd\0\u0eee\0\u0f1f\0\u0f50\0\u0f81"+
    "\0\u0fb2\0\u0fe3\0\61\0\u1014\0\61\0\u1045\0\61\0\61"+
    "\0\61\0\61\0\u1076\0\u10a7\0\u10d8\0\u1109\0\u113a\0\u116b"+
    "\0\u119c\0\u11cd\0\u11fe\0\u122f\0\61\0\u1260\0\u1291\0\u12c2"+
    "\0\61\0\u12f3\0\u1324\0\u1355\0\u1386\0\u13b7\0\u13e8\0\u1419"+
    "\0\u144a\0\u147b\0\61\0\u14ac\0\u14dd\0\61\0\u150e\0\u153f"+
    "\0\u1570\0\u15a1\0\u15d2\0\u1603\0\u1634\0\u1665\0\61";

  private static int [] zzUnpackRowMap() {
    int [] result = new int[151];
    int offset = 0;
    offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackRowMap(String packed, int offset, int [] result) {
    int i = 0;  /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length() - 1;
    while (i < l) {
      int high = packed.charAt(i++) << 16;
      result[j++] = high | packed.charAt(i++);
    }
    return j;
  }

  /**
   * The transition table of the DFA
   */
  private static final int [] ZZ_TRANS = zzUnpacktrans();

  private static final String ZZ_TRANS_PACKED_0 =
    "\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11"+
    "\1\12\1\2\1\13\2\2\1\14\2\2\1\15\4\2"+
    "\1\16\1\17\1\2\1\20\1\21\2\2\1\22\1\23"+
    "\1\24\2\2\1\25\1\2\1\26\3\2\1\27\1\30"+
    "\1\31\1\2\1\32\3\2\1\33\1\34\62\0\1\3"+
    "\70\0\1\35\73\0\1\36\75\0\1\37\7\0\1\40"+
    "\42\0\1\41\40\0\1\42\17\0\1\43\60\0\1\44"+
    "\11\0\1\45\55\0\1\46\63\0\1\47\4\0\1\50"+
    "\44\0\1\51\4\0\1\52\1\53\47\0\1\54\62\0"+
    "\1\55\60\0\1\56\13\0\1\57\2\0\1\60\61\0"+
    "\1\61\36\0\1\62\32\0\1\63\75\0\1\64\75\0"+
    "\1\65\70\0\1\66\60\0\1\67\21\0\1\70\60\0"+
    "\1\71\120\0\1\72\54\0\1\73\64\0\1\74\57\0"+
    "\1\75\55\0\1\76\62\0\1\77\63\0\1\100\55\0"+
    "\1\101\63\0\1\102\51\0\1\103\65\0\1\104\52\0"+
    "\1\105\65\0\1\106\61\0\1\107\27\0\1\110\66\0"+
    "\1\111\100\0\1\112\55\0\1\113\40\0\1\114\53\0"+
    "\1\115\122\0\1\116\37\0\1\117\73\0\1\120\45\0"+
    "\1\121\57\0\1\122\71\0\1\123\50\0\1\124\75\0"+
    "\1\125\43\0\1\126\75\0\1\127\57\0\1\130\44\0"+
    "\1\131\25\0\1\132\101\0\1\133\70\0\1\134\71\0"+
    "\1\135\51\0\1\136\54\0\1\137\46\0\1\140\112\0"+
    "\1\141\56\0\1\142\60\0\1\143\60\0\1\144\45\0"+
    "\1\145\60\0\1\146\60\0\1\147\75\0\1\150\46\0"+
    "\1\151\55\0\1\152\32\0\1\153\62\0\1\154\121\0"+
    "\1\155\45\0\1\156\66\0\1\157\65\0\1\160\60\0"+
    "\1\161\47\0\1\162\72\0\1\163\30\0\1\164\100\0"+
    "\1\165\45\0\1\166\64\0\1\167\74\0\1\170\52\0"+
    "\1\171\52\0\1\172\57\0\1\173\62\0\1\174\61\0"+
    "\1\175\74\0\1\176\56\0\1\177\42\0\1\200\64\0"+
    "\1\201\60\0\1\202\56\0\1\203\55\0\1\204\77\0"+
    "\1\205\62\0\1\206\42\0\1\207\60\0\1\210\66\0"+
    "\1\211\27\0\1\212\112\0\1\213\63\0\1\214\71\0"+
    "\1\215\46\0\1\216\33\0\1\217\51\0\1\220\77\0"+
    "\1\221\44\0\1\222\55\0\1\223\64\0\1\224\76\0"+
    "\1\225\57\0\1\226\34\0\1\227\53\0";

  private static int [] zzUnpacktrans() {
    int [] result = new int[5782];
    int offset = 0;
    offset = zzUnpacktrans(ZZ_TRANS_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpacktrans(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }


  /* error codes */
  private static final int ZZ_UNKNOWN_ERROR = 0;
  private static final int ZZ_NO_MATCH = 1;
  private static final int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  private static final String[] ZZ_ERROR_MSG = {
    "Unknown internal scanner error",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state {@code aState}
   */
  private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();

  private static final String ZZ_ATTRIBUTE_PACKED_0 =
    "\1\0\1\11\2\1\10\11\4\1\1\11\11\1\2\11"+
    "\14\0\1\11\23\0\1\11\3\0\1\11\5\0\1\11"+
    "\7\0\1\11\1\0\2\11\6\0\3\11\5\0\1\11"+
    "\11\0\1\11\1\0\1\11\1\0\4\11\12\0\1\11"+
    "\3\0\1\11\11\0\1\11\2\0\1\11\10\0\1\11";

  private static int [] zzUnpackAttribute() {
    int [] result = new int[151];
    int offset = 0;
    offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
    return result;
  }

  private static int zzUnpackAttribute(String packed, int offset, int [] result) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      do result[j++] = value; while (--count > 0);
    }
    return j;
  }

  /** the input device */
  private java.io.Reader zzReader;

  /** the current state of the DFA */
  private int zzState;

  /** the current lexical state */
  private int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private CharSequence zzBuffer = "";

  /** the textposition at the last accepting state */
  private int zzMarkedPos;

  /** the current text position in the buffer */
  private int zzCurrentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int zzStartRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int zzEndRead;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  private boolean zzAtEOF;

  /** Number of newlines encountered up to the start of the matched text. */
  @SuppressWarnings("unused")
  private int yyline;

  /** Number of characters from the last newline up to the start of the matched text. */
  @SuppressWarnings("unused")
  protected int yycolumn;

  /** Number of characters up to the start of the matched text. */
  @SuppressWarnings("unused")
  private long yychar;

  /** Whether the scanner is currently at the beginning of a line. */
  @SuppressWarnings("unused")
  private boolean zzAtBOL = true;

  /** Whether the user-EOF-code has already been executed. */
  @SuppressWarnings("unused")
  private boolean zzEOFDone;


  /**
   * Creates a new scanner
   *
   * @param   in  the java.io.Reader to read input from.
   */
  public GnoLexer(java.io.Reader in) {
    this.zzReader = in;
  }


  /** Returns the maximum size of the scanner buffer, which limits the size of tokens. */
  private int zzMaxBufferLen() {
    return Integer.MAX_VALUE;
  }

  /**  Whether the scanner buffer can grow to accommodate a larger token. */
  private boolean zzCanGrow() {
    return true;
  }

  /**
   * Translates raw input code points to DFA table row
   */
  private static int zzCMap(int input) {
    int offset = input & 255;
    return offset == input ? ZZ_CMAP_BLOCKS[offset] : ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input >> 8] | offset];
  }

  public final int getTokenStart() {
    return zzStartRead;
  }

  public final int getTokenEnd() {
    return getTokenStart() + yylength();
  }

  public void reset(CharSequence buffer, int start, int end, int initialState) {
    zzBuffer = buffer;
    zzCurrentPos = zzMarkedPos = zzStartRead = start;
    zzAtEOF  = false;
    zzAtBOL = true;
    zzEndRead = end;
    yybegin(initialState);
  }

  /**
   * Refills the input buffer.
   *
   * @return      {@code false}, iff there was new input.
   *
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  private boolean zzRefill() throws java.io.IOException {
    return true;
  }


  /**
   * Returns the current lexical state.
   */
  public final int yystate() {
    return zzLexicalState;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  public final void yybegin(int newState) {
    zzLexicalState = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  public final CharSequence yytext() {
    return zzBuffer.subSequence(zzStartRead, zzMarkedPos);
  }


  /**
   * Returns the character at position {@code pos} from the
   * matched text.
   *
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  public final char yycharat(int pos) {
    return zzBuffer.charAt(zzStartRead+pos);
  }


  /**
   * Returns the length of the matched text region.
   */
  public final int yylength() {
    return zzMarkedPos-zzStartRead;
  }


  /**
   * Reports an error that occurred while scanning.
   *
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void zzScanError(int errorCode) {
    String message;
    try {
      message = ZZ_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
    }

    throw new Error(message);
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  public void yypushback(int number)  {
    if ( number > yylength() )
      zzScanError(ZZ_PUSHBACK_2BIG);

    zzMarkedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  public IElementType advance() throws java.io.IOException
  {
    int zzInput;
    int zzAction;

    // cached fields:
    int zzCurrentPosL;
    int zzMarkedPosL;
    int zzEndReadL = zzEndRead;
    CharSequence zzBufferL = zzBuffer;

    int [] zzTransL = ZZ_TRANS;
    int [] zzRowMapL = ZZ_ROWMAP;
    int [] zzAttrL = ZZ_ATTRIBUTE;

    while (true) {
      zzMarkedPosL = zzMarkedPos;

      zzAction = -1;

      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

      zzState = ZZ_LEXSTATE[zzLexicalState];

      // set up zzAction for empty match case:
      int zzAttributes = zzAttrL[zzState];
      if ( (zzAttributes & 1) == 1 ) {
        zzAction = zzState;
      }


      zzForAction: {
        while (true) {

          if (zzCurrentPosL < zzEndReadL) {
            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL);
            zzCurrentPosL += Character.charCount(zzInput);
          }
          else if (zzAtEOF) {
            zzInput = YYEOF;
            break zzForAction;
          }
          else {
            // store back cached positions
            zzCurrentPos  = zzCurrentPosL;
            zzMarkedPos   = zzMarkedPosL;
            boolean eof = zzRefill();
            // get translated positions and possibly new buffer
            zzCurrentPosL  = zzCurrentPos;
            zzMarkedPosL   = zzMarkedPos;
            zzBufferL      = zzBuffer;
            zzEndReadL     = zzEndRead;
            if (eof) {
              zzInput = YYEOF;
              break zzForAction;
            }
            else {
              zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL);
              zzCurrentPosL += Character.charCount(zzInput);
            }
          }
          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMap(zzInput) ];
          if (zzNext == -1) break zzForAction;
          zzState = zzNext;

          zzAttributes = zzAttrL[zzState];
          if ( (zzAttributes & 1) == 1 ) {
            zzAction = zzState;
            zzMarkedPosL = zzCurrentPosL;
            if ( (zzAttributes & 8) == 8 ) break zzForAction;
          }

        }
      }

      // store back cached position
      zzMarkedPos = zzMarkedPosL;

      if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
        zzAtEOF = true;
        return null;
      }
      else {
        switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
          case 1:
            { return BAD_CHARACTER;
            }
          // fall through
          case 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
               63, 64, 65, 66, 67, 68, 69, 70, 71, 72: break;
          case 2:
            { return WHITE_SPACE;
            }
            case 3:
            { return LPAREN;
            }
            case 4:
            { return RPAREN;
            }
            case 5:
            { return MUL;
            }
            case 6:
            { return PLUS;
            }
            case 7:
            { return COMMA;
            }
            case 8:
            { return MINUS;
            }
            case 9:
            { return DIV;
            }
            case 10:
            { return ASSIGN;
            }
            case 11:
            { return LBRACK;
            }
            case 12:
            { return RBRACK;
            }
            case 13:
            { return LBRACE;
            }
            case 14:
            { return RBRACE;
            }
            case 15:
            { return IF;
            }
            case 16:
            { return FOR;
            }
            case 17:
            { return MAP;
            }
            case 18:
            { return VAR;
            }
            case 19:
            { return CASE;
            }
            case 20:
            { return ELSE;
            }
            case 21:
            { return FUNC;
            }
            case 22:
            { return TYPE;
            }
            case 23:
            { return STRING;
            }
            case 24:
            { return COLON;
            }
            case 25:
            { return CONST;
            }
            case 26:
            { return INT;
            }
            case 27:
            { return IMPORT;
            }
            case 28:
            { return RETURN;
            }
            case 29:
            { return SELECT;
            }
            case 30:
            { return STRUCT;
            }
            case 31:
            { return SWITCH;
            }
            case 32:
            { return SIGNATURE;
            }
            case 33:
            { return INTERFACE;
            }
            case 34:
            { return VARDECLARATION;
            }
            case 35:
            { return IDENTIFIER;
            }
            default:
            zzScanError(ZZ_NO_MATCH);
          }
      }
    }
  }


}
